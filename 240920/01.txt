- Next

라이브러리 VS 프레임워크

라이브러리:
- 코드내에서 사용한 것 
- 코드 내에서 사용하려고 설치하는 것이지만 사용의 주체는 사용자
- 우리가 필요할 떄 사용할 수 있는 것

React 는 UI 인터페이스를 build하는데 사용하는 라이브러리

프레임워크:
- 우리를 위해 많은 일들을 대신 해준다
- 우리가 규칙을 지켜야 하는 것

next.js

-----------------------------------------------------------------------------
수동 설치
npm init -y
 npm i react@latest next@latest reat-dom@latest

-app이란 폴더 안에 page.tsx를 만들어야 한다

페이지
- app폴더에 있는 page는 기본 / 페이지 이다.
- 새로운 페이지를 만들떄에는 app > 생성할 파일명으로 폴더 생성 이후 page.tsx 생성
- 파일명이 url이고 실질적인 페이지는 page.tsx이다

not-found
- 없는 페이지를 만들떄 not-found.tsx를 생성하여 만듬

네비게이션 바
- 페이지를 이동할때 사용하는테 태그는 Link

layout
- 레이아웃은 중첩이 가능하다.

메타데이터
- 

 Dynamic Routes (다이나믹 라우트)
- [id] 로 파일명을 지으면 된다

params
- 

-------------------------------------------------------------------------------
https://nomad-movies.nomadcoders.workers.dev

fetch
- server component에서 next가 fetch한 것을 기억해서 로딩이 프론트에서 되지 않는다
- 데이터가 도착해야 사용자가 화면을 볼 수 있다.

loading
- loading 페이지를 따로 만들어 구성하면 자동으로 로딩페이지가 보여진다.
- 브라우저에게 백엔드에서 통신이 아직 마무리되지 않았고 기다려줘야 한다고 하는 것

Promise.all()
- 병렬적 fetch
- js에서 비동기 작업을 동시에 실행하고 모든 작업이 완료될 때까지 기다렸다가 결과를 배열 형태로 반환하는 함수
- 단점: 둘다 로딩이 끝나야 화면에 출력할 수 있음

Suspense
- promise.all의 단점을 보완
- 데이터 로딩이 완료된 컴포넌트 순서대로 결과를 보여준다.
- 병렬 프로그래밍
- 각각 데이터들의 로딩중에 fallback을 이용하여 로딩화면을 띄울 수 있다.

error
- error.tsx를 만들어 오류 처리를 하면 페이지가 깨지지 않고 오류 메세지를 전달할 수 있다.
- page.tsx와 같은 폴더에 만들어야 작동한다.

vercel.com
- 배포사이트
-------------------------------------------------------------------------------

SSR vs CSR
- 랜더링: js function을 가져와서 브라우저가 이해할 수 있는 html로 변환하는 작업
- CSR: 모든 렌더링이 클라이언트 측에서 발생
클라이언트는 js를 로드하고 js가 ui를 빌드함
- SSR: next로 웹 사이트를 빌드할 떄 기본적으로 ssr을 사용함 
모든 컴포넌트와 페이지들이 먼저 서버에서 랜더링

Hydration
- ssr을 통해 만들어 진 인터렉티브 하지 않은 html을 클라이언트 측 js를 사용하여 인터렉티브한 컴포넌트로 변환하는 과정
- 서버환경에서 이미 랜더링된 html에 react를 붙이는 것

"use client"
- 백에서 랜더되고 프론트에서 hydrate됨을 의미
- 모든 컴포넌트는 서버 컴포넌트가 기본. 따라서 클라이언트를 사용하려면 use client를 입력하면된다
- 사용자와 상호작용하는 경우 사용한다.












